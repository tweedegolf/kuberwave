use serde_derive::{Deserialize, Serialize};
use std::collections::HashSet;
use std::path::{Path, PathBuf};
use std::str::FromStr;

use crate::error::{ErrorKind, Result};
use crate::kubectl::Kubectl;
use crate::project::templates::*;
use crate::resourcefile::Resourcefile;
use crate::secrets::read_secret_from_file;
use failure::ResultExt;
use std::collections::HashMap;
use tera::Context;

#[derive(Serialize, Deserialize, Debug, PartialEq, Eq, Hash, Clone)]
#[serde(rename_all = "camelCase")]
pub enum ManifestOptions {
    #[serde(rename = "pd-ssd")]
    PdSsd,
    #[serde(rename = "pd-hdd")]
    PdHdd,
}

#[derive(Serialize, Deserialize, Debug, Clone, Copy)]
#[derive(Default)]
pub enum EncryptionType {
    #[serde(rename = "sops")]
    SOPS,
    #[serde(rename = "ansible-vault")]
    #[default]
    AnsibleVault,
}

pub struct UnknownEncryptionType;

impl FromStr for EncryptionType {
    type Err = UnknownEncryptionType;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        match s {
            "sops" => Ok(EncryptionType::SOPS),
            "ansible-vault" => Ok(EncryptionType::AnsibleVault),
            _ => Err(UnknownEncryptionType),
        }
    }
}



/// A docker registry secret JSON file generated by `docker login`.
#[derive(Serialize, Deserialize, Debug, Clone)]
pub struct RegcredSecret {
    name: String,
    file: String,
    #[serde(default)]
    encryption: EncryptionType,
}

#[derive(Serialize, Deserialize, Debug, Clone)]
pub struct OpaqueSecret {
    name: String,
    file: String,
    #[serde(default)]
    encryption: EncryptionType,
}

#[derive(Serialize, Deserialize, Debug, Clone)]
pub struct FileSecret {
    name: String,
    dest: String,
    file: String,
    #[serde(default)]
    template: bool,
    #[serde(default)]
    encryption: EncryptionType,
}

#[derive(Serialize, Deserialize, Debug, Clone)]
pub struct ContextSecret {
    file: String,
    #[serde(default)]
    encryption: EncryptionType,
}

#[derive(Serialize, Deserialize, Debug, Clone)]
#[serde(tag = "type")]
pub enum Secret {
    Regcred(RegcredSecret),
    Opaque(OpaqueSecret),
    File(FileSecret),
    Context(ContextSecret),
}

/// A hardcopy of a file or folder as a ConfigMap or Secret.
#[derive(Serialize, Deserialize, Debug, Clone)]
pub struct Hardmount {
    name: String,
    dest: String,
    src: String,
    /// Emit as a Secret instead of a ConfigMap.
    #[serde(default)]
    secret: bool,
    /// Parse as templates.
    #[serde(default)]
    template: bool,
    /// Optionally remap (copy, not move) file entries in the ConfigMap from something else.
    /// Keys are the destinations, values are the sources.
    #[serde(default)]
    remap: Option<HashMap<String, String>>,
}

#[derive(Serialize, Deserialize, Debug, Clone)]
#[serde(deny_unknown_fields)]
pub struct Manifest {
    pub version: u8,
    pub namespace: String,
    pub templates: Option<Vec<PathBuf>>,
    pub options: Option<HashSet<ManifestOptions>>,
    #[serde(alias = "defaultNetworkPolicy")]
    pub default_network_policy: Option<bool>,
    pub ingress: Option<Vec<Ingress>>,
    pub env: Option<HashSet<String>>,
    pub secrets: Option<Vec<Secret>>,
    pub hardmounts: Option<Vec<Hardmount>>,
}

#[derive(Serialize, Deserialize, PartialEq, Debug, Clone)]
#[derive(Default)]
pub enum CertificateSolver {
    #[default]
    HTTP,
    DNS,
    NONE,
}



#[derive(Serialize, Deserialize, Debug, Clone)]
pub struct Ingress {
    pub name: String,
    pub hosts: Vec<String>,
    pub service: String,
    pub port: u16,
    pub certificate: String,
    #[serde(default)]
    pub certificate_solver: CertificateSolver,
    pub annotations: Option<HashMap<String, String>>,
}

impl Manifest {
    pub fn to_sourcefiles(
        &self,
        base: &Path,
        mut context: Context,
        vaultkey: Option<&str>,
        kubectl: Option<&Kubectl>,
    ) -> Result<Vec<Resourcefile>> {
        let mut files: Vec<Resourcefile> = vec![];

        match &self.env {
            Some(es) => {
                for env in es {
                    let value = std::env::var(env).context(ErrorKind::EnvError {
                        name: env.to_string(),
                    })?;
                    context.insert(env, &value);
                }
            }
            None => (),
        }

        match &self.secrets {
            Some(ss) => {
                for secret in ss {
                    secret.apply_context(base, &mut context, vaultkey)?;
                }

                for secret in ss {
                    let sf = secret.to_sourcefile(base, &context, vaultkey);
                    if let Some(sf) = sf {
                        files.push(sf)
                    }
                }
            }
            None => (),
        }

        if let Some(true) = &self.default_network_policy {
            files.push(NetworkPolicyTemplate::instantiate(&self.namespace, &self.ingress));
        }

        match &self.ingress {
            Some(is) => {
                for i in is {
                    if i.certificate_solver != CertificateSolver::NONE {
                        let resource_version = kubectl
                            .map(|kubectl| {
                                kubectl.get_resource_version("certificate", &i.certificate)
                            })
                            .transpose()?
                            .flatten();
                        files.push(CertificateTemplate::instantiate(
                            crate::project::templates::OptRevisionVersion(
                                resource_version.as_deref(),
                            ),
                            i,
                            IssuerMode::Production,
                        ));
                    }
                    files.push(IngressTemplate::instantiate(i));
                }
            }
            None => (),
        }

        match &self.templates {
            Some(ts) => {
                let template_base = base.join("templates");
                for template in ts {
                    let parsed =
                        crate::util::process_template(&template_base.join(template), &context)?;
                    files.push(Resourcefile {
                        name: template.to_string_lossy().to_string(),
                        buffer: parsed,
                    })
                }
            }
            None => (),
        }

        match &self.hardmounts {
            Some(hms) => {
                for hardmount in hms {
                    files.push(hardmount.to_sourcefile(base, &context)?)
                }
            }
            None => (),
        }

        Ok(files)
    }
}

impl RegcredSecret {
    pub fn to_sourcefile(&self, base: &Path, key: Option<&str>) -> Resourcefile {
        let content = read_secret_from_file(self.encryption, &base.join(&self.file), key).unwrap();
        SecretRegcredTemplate::instantiate(&self.name, &content)
    }
}

impl OpaqueSecret {
    pub fn to_sourcefile(&self, base: &Path, key: Option<&str>) -> Resourcefile {
        let content = read_secret_from_file(self.encryption, &base.join(&self.file), key).unwrap();
        let secrets: HashMap<String, String> = serde_yaml::from_slice(&content).unwrap();
        SecretOpaqueTemplate::instantiate(
            &self.name,
            secrets
                .into_iter()
                .map(|(k, v)| (k, v.into_bytes()))
                .collect(),
        )
    }
}

impl FileSecret {
    pub fn to_sourcefile(&self, base: &Path, context: &Context, key: Option<&str>) -> Resourcefile {
        let file = base.join(&self.file);
        let mut content = read_secret_from_file(self.encryption, &file, key).unwrap();

        if self.template {
            content = tera::Tera::one_off(&String::from_utf8(content).unwrap(), context, false)
                .unwrap()
                .into_bytes()
        }

        SecretOpaqueTemplate::instantiate(
            &self.name,
            [(self.dest.to_string(), content)].iter().cloned().collect(),
        )
    }
}

impl ContextSecret {
    pub fn apply_context(
        &self,
        base: &Path,
        context: &mut Context,
        key: Option<&str>,
    ) -> Result<()> {
        let content = read_secret_from_file(self.encryption, &base.join(&self.file), key).unwrap();
        let content = String::from_utf8(content).unwrap();
        let content = yaml_rust::YamlLoader::load_from_str(&content).unwrap();

        crate::util::append_yaml_to_context(content, context)
    }
}

impl Secret {
    pub fn to_sourcefile(
        &self,
        base: &Path,
        context: &Context,
        key: Option<&str>,
    ) -> Option<Resourcefile> {
        match self {
            Secret::Opaque(s) => Some(s.to_sourcefile(base, key)),
            Secret::Regcred(s) => Some(s.to_sourcefile(base, key)),
            Secret::File(s) => Some(s.to_sourcefile(base, context, key)),
            Secret::Context(_) => None,
        }
    }

    pub fn apply_context(
        &self,
        base: &Path,
        context: &mut Context,
        key: Option<&str>,
    ) -> Result<()> {
        match self {
            Secret::Opaque(_) => (),
            Secret::Regcred(_) => (),
            Secret::File(_) => (),
            Secret::Context(s) => s.apply_context(base, context, key)?,
        }

        Ok(())
    }
}

impl Hardmount {
    pub fn to_sourcefile(&self, base: &Path, context: &Context) -> Result<Resourcefile> {
        let path = base.join(&self.src);

        let files = if path.is_dir() {
            // We only support direct paths.
            // TODO recursively iterate over directory.
            path.read_dir()
                .map_err(|_| ErrorKind::FileReadError { name: path })?
                .filter_map(|entry| {
                    let entry = entry.ok()?;
                    if entry.metadata().ok()?.is_file() {
                        Some(entry.path())
                    } else {
                        None
                    }
                })
                .collect()
        } else {
            vec![path]
        };

        let read_f = |path: &Path| {
            if self.template {
                crate::util::process_template(path, context).map(|b| b.into_bytes())
            } else {
                std::fs::read(path).map_err(|_| {
                    ErrorKind::FileReadError {
                        name: path.to_path_buf(),
                    }
                    .into()
                })
            }
        };

        let file_content: Result<Vec<(String, Vec<u8>)>> = files
            .into_iter()
            .map(|path| {
                Ok((
                    path.file_name().unwrap().to_str().unwrap().to_string(),
                    read_f(&path)?,
                ))
            })
            .collect();

        let mut file_content: HashMap<String, Vec<u8>> = file_content?.into_iter().collect();

        if let Some(remap) = &self.remap {
            for (dst, src) in remap {
                let new_v = file_content
                    .get(src)
                    .ok_or(ErrorKind::ManifestError)?
                    .clone();
                file_content.insert(dst.clone(), new_v);
            }
        }

        let result = if self.secret {
            SecretOpaqueTemplate::instantiate(&self.name, file_content)
        } else {
            ConfigMapTemplate::instantiate(&self.name, vec![], file_content.into_iter().collect())
        };

        Ok(result)
    }
}
